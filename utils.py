"""
Utility functions for the Startup Guide Tool
"""
import re
from datetime import datetime
from typing import List, Optional, Dict
import hashlib

def format_markdown_response(text: str) -> str:
    """
    Format AI response with better markdown rendering
    """
    # Ensure proper heading spacing
    text = re.sub(r'\n(#{1,6}\s)', r'\n\n\1', text)
    
    # Ensure proper list spacing
    text = re.sub(r'\n(\d+\.|\*|-)\s', r'\n\1 ', text)
    
    # Add spacing around code blocks
    text = re.sub(r'```', r'\n```\n', text)
    
    return text.strip()

def extract_checklist_items(text: str, max_items: int = 15) -> List[str]:
    """
    Extract actionable checklist items from AI response
    Uses multiple patterns to identify action items
    """
    checklist = []
    
    # Pattern 1: Numbered lists (1. Item, 2. Item)
    numbered_pattern = r'^\s*\d+\.\s+(.+)$'
    numbered_matches = re.findall(numbered_pattern, text, re.MULTILINE)
    
    # Pattern 2: Bullet points (- Item, * Item)
    bullet_pattern = r'^\s*[-*]\s+(.+)$'
    bullet_matches = re.findall(bullet_pattern, text, re.MULTILINE)
    
    # Pattern 3: Action verbs at start of sentences
    action_pattern = r'^\s*([A-Z][a-z]+\s+[a-z]+\s+[^.!?]{10,}[.!?])'
    action_matches = re.findall(action_pattern, text, re.MULTILINE)
    
    # Pattern 4: Checkbox items ([ ] Item, [x] Item)
    checkbox_pattern = r'\[[ x]\]\s+(.+)'
    checkbox_matches = re.findall(checkbox_pattern, text, re.IGNORECASE)
    
    # Combine all matches
    all_items = numbered_matches + bullet_matches + checkbox_matches
    
    # Filter and clean items
    for item in all_items:
        item = item.strip()
        # Remove markdown formatting
        item = re.sub(r'\*\*(.+?)\*\*', r'\1', item)  # Bold
        item = re.sub(r'\*(.+?)\*', r'\1', item)      # Italic
        item = re.sub(r'`(.+?)`', r'\1', item)        # Code
        
        # Only include items that look like actions
        if (
            len(item) > 15 and 
            len(item) < 150 and 
            item not in checklist and
            not item.startswith('http')  # Exclude URLs
        ):
            checklist.append(item)
            
            if len(checklist) >= max_items:
                break
    
    return checklist

def export_to_markdown(
    query: str,
    response: str,
    topic: str,
    checklist: Optional[List[str]] = None
) -> str:
    """
    Export conversation to markdown format
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    markdown = f"""# Startup Guidance Export
**Topic:** {topic}  
**Generated:** {timestamp}

---

## Your Question
{query}

---

## AI Guidance
{response}

---
"""
    
    if checklist:
        markdown += "\n## Action Checklist\n"
        for item in checklist:
            markdown += f"- [ ] {item}\n"
        markdown += "\n---\n"
    
    markdown += """
## Disclaimer
This is AI-generated general advice. Always consult with legal, financial, or domain experts for critical business decisions.

---
*Generated by AI Startup Guidance Tool by SitaRaman*
"""
    
    return markdown

def validate_api_key_format(api_key: str) -> bool:
    """
    Basic validation of API key format
    """
    if not api_key or len(api_key) < 20:
        return False
    
    # OpenRouter keys typically start with 'sk-or-'
    if api_key.startswith('sk-or-v1-'):
        return True
    
    # Also accept generic format
    if api_key.startswith('sk-'):
        return True
    
    return False

def estimate_tokens(text: str) -> int:
    """
    Rough estimation of token count
    Rule of thumb: ~4 characters per token for English
    """
    return len(text) // 4

def sanitize_filename(filename: str) -> str:
    """
    Sanitize filename for safe file downloads
    """
    # Remove invalid characters
    filename = re.sub(r'[<>:"/\\|?*]', '', filename)
    # Replace spaces with underscores
    filename = filename.replace(' ', '_')
    # Limit length
    filename = filename[:100]
    return filename

def hash_query(query: str) -> str:
    """
    Create a hash of query for caching purposes
    """
    return hashlib.md5(query.encode()).hexdigest()[:8]

def calculate_reading_time(text: str) -> int:
    """
    Estimate reading time in minutes
    Average reading speed: 200-250 words per minute
    """
    word_count = len(text.split())
    reading_time = max(1, word_count // 225)  # Conservative estimate
    return reading_time

def format_timestamp(dt: datetime) -> str:
    """
    Format datetime to readable string
    """
    now = datetime.now()
    diff = now - dt
    
    if diff.days == 0:
        if diff.seconds < 60:
            return "Just now"
        elif diff.seconds < 3600:
            minutes = diff.seconds // 60
            return f"{minutes} minute{'s' if minutes > 1 else ''} ago"
        else:
            hours = diff.seconds // 3600
            return f"{hours} hour{'s' if hours > 1 else ''} ago"
    elif diff.days == 1:
        return "Yesterday"
    elif diff.days < 7:
        return f"{diff.days} days ago"
    else:
        return dt.strftime("%B %d, %Y")

def truncate_text(text: str, max_length: int = 100, suffix: str = "...") -> str:
    """
    Truncate text to specified length
    """
    if len(text) <= max_length:
        return text
    return text[:max_length - len(suffix)].strip() + suffix

def extract_metrics_from_response(text: str) -> List[Dict[str, str]]:
    """
    Extract key metrics mentioned in the response
    """
    metrics = []
    
    # Common startup metrics patterns
    metric_patterns = [
        r'(CAC|LTV|MRR|ARR|Churn|Retention|DAU|MAU|NPS|Conversion)\s*[:\-]?\s*([^.\n]+)',
        r'(\w+\s+rate)\s*[:\-]?\s*([^.\n]+)',
    ]
    
    for pattern in metric_patterns:
        matches = re.findall(pattern, text, re.IGNORECASE)
        for match in matches:
            metrics.append({
                "metric": match[0].strip(),
                "description": match[1].strip()
            })
    
    return metrics[:10]  # Limit to top 10 metrics

def suggest_follow_up_questions(topic: str, query: str) -> List[str]:
    """
    Suggest relevant follow-up questions based on topic
    """
    follow_ups = {
        "scaling": [
            "What are the infrastructure costs for scaling?",
            "How to handle customer support at scale?",
            "When should I hire a CTO or technical co-founder?",
            "What automation tools can help with scaling?"
        ],
        "funding": [
            "How long does fundraising typically take?",
            "What equity should I give to investors?",
            "How to value my startup for fundraising?",
            "What are alternatives to VC funding?"
        ],
        "team": [
            "How much equity should early employees get?",
            "Remote vs in-office: pros and cons?",
            "How to onboard remote team members effectively?",
            "Building company culture in a remote team"
        ],
        "documents": [
            "What's the difference between LLC and C-Corp?",
            "How to handle IP with contractors?",
            "When do I need a privacy policy?",
            "What are 83(b) elections and why do they matter?"
        ],
        "product": [
            "How to prioritize feature requests?",
            "When is the right time to pivot?",
            "How to measure product-market fit?",
            "Building a product roadmap for investors"
        ],
        "marketing": [
            "What's a good customer acquisition cost (CAC)?",
            "How to calculate marketing ROI?",
            "Best practices for email marketing?",
            "How to build an SEO strategy from scratch?"
        ]
    }
    
    return follow_ups.get(topic, [
        "What are the biggest risks I should be aware of?",
        "What resources or tools do you recommend?",
        "How long will this typically take?",
        "What are common mistakes to avoid?"
    ])

def analyze_sentiment(text: str) -> str:
    """
    Simple sentiment analysis based on keyword presence
    """
    positive_keywords = ['success', 'growth', 'opportunity', 'achieve', 'win', 'excellent', 'great']
    negative_keywords = ['risk', 'challenge', 'difficult', 'problem', 'fail', 'avoid', 'warning']
    
    positive_count = sum(1 for word in positive_keywords if word in text.lower())
    negative_count = sum(1 for word in negative_keywords if word in text.lower())
    
    if positive_count > negative_count * 1.5:
        return "positive"
    elif negative_count > positive_count * 1.5:
        return "cautionary"
    else:
        return "balanced"

def format_currency(amount: float, currency: str = "USD") -> str:
    """
    Format currency with proper symbols and separators
    """
    symbols = {
        "USD": "$",
        "EUR": "€",
        "GBP": "£",
        "INR": "₹"
    }
    symbol = symbols.get(currency, "$")
    
    if amount >= 1_000_000:
        return f"{symbol}{amount/1_000_000:.1f}M"
    elif amount >= 1_000:
        return f"{symbol}{amount/1_000:.1f}K"
    else:
        return f"{symbol}{amount:.2f}"

def parse_timeline(text: str) -> List[Dict[str, str]]:
    """
    Extract timeline information from response
    """
    timeline_items = []
    
    # Pattern for time-based items (Week 1, Month 1-3, etc.)
    pattern = r'(Week|Month|Quarter|Year)\s+(\d+(?:-\d+)?)[:\-]?\s*([^.\n]+)'
    matches = re.findall(pattern, text, re.IGNORECASE)
    
    for match in matches:
        timeline_items.append({
            "period": f"{match[0]} {match[1]}",
            "action": match[2].strip()
        })
    
    return timeline_items

def calculate_progress_score(checklist_states: List[bool]) -> Dict[str, any]:
    """
    Calculate progress metrics from checklist
    """
    total = len(checklist_states)
    completed = sum(checklist_states)
    
    if total == 0:
        return {"percentage": 0, "completed": 0, "remaining": 0, "status": "not_started"}
    
    percentage = (completed / total) * 100
    
    if percentage == 100:
        status = "completed"
    elif percentage >= 50:
        status = "in_progress_good"
    elif percentage > 0:
        status = "in_progress"
    else:
        status = "not_started"
    
    return {
        "percentage": round(percentage, 1),
        "completed": completed,
        "remaining": total - completed,
        "status": status
    }

# Response quality scoring
def score_response_quality(response: str) -> Dict[str, any]:
    """
    Score the quality and completeness of AI response
    """
    score = 0
    max_score = 100
    feedback = []
    
    # Length check (400-1000 words is ideal)
    word_count = len(response.split())
    if 400 <= word_count <= 1000:
        score += 20
    elif word_count < 400:
        feedback.append("Response might be too brief")
        score += 10
    else:
        feedback.append("Response is comprehensive")
        score += 15
    
    # Structure check (has headers/sections)
    if re.search(r'#{1,3}\s+\w+', response):
        score += 20
        feedback.append("Well-structured with sections")
    
    # Actionable items check
    action_verbs = ['create', 'build', 'develop', 'implement', 'establish', 'design', 'launch']
    action_count = sum(1 for verb in action_verbs if verb in response.lower())
    if action_count >= 5:
        score += 20
        feedback.append("Contains actionable advice")
    elif action_count >= 3:
        score += 10
    
    # Resources/tools mentioned
    if re.search(r'(tool|resource|platform|software)', response, re.IGNORECASE):
        score += 15
        feedback.append("Includes helpful resources")
    
    # Numbers/metrics mentioned
    if re.search(r'\d+%|\d+\s+(months|weeks|days)', response):
        score += 15
        feedback.append("Contains specific metrics/timelines")
    
    # Examples or case studies
    if re.search(r'(example|case study|for instance)', response, re.IGNORECASE):
        score += 10
        feedback.append("Includes examples")
    
    return {
        "score": min(score, max_score),
        "grade": "Excellent" if score >= 80 else "Good" if score >= 60 else "Fair",
        "feedback": feedback,
        "word_count": word_count
    }